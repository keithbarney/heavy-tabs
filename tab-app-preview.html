<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tab Editor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel" data-type="module">
const { useState, useEffect, useCallback, useRef } = React;

// Spacegray / Base16 Ocean Dark color palette
const themes = {
  dark: {
    bg: '#2b303b',
    bgAlt: '#343d46',
    bgHighlight: '#4f5b66',
    border: '#65737e',
    text: '#c0c5ce',
    textMuted: '#a7adba',
    textBright: '#eff1f5',
    accent: '#8fa1b3',
    accentAlt: '#96b5b4',
    red: '#bf616a',
    orange: '#d08770',
    yellow: '#ebcb8b',
    green: '#a3be8c',
    purple: '#b48ead',
    selection: '#4f5b66',
  },
  light: {
    bg: '#eff1f5',
    bgAlt: '#dfe1e8',
    bgHighlight: '#c0c5ce',
    border: '#a7adba',
    text: '#343d46',
    textMuted: '#65737e',
    textBright: '#2b303b',
    accent: '#8fa1b3',
    accentAlt: '#96b5b4',
    red: '#bf616a',
    orange: '#d08770',
    yellow: '#ebcb8b',
    green: '#a3be8c',
    purple: '#b48ead',
    selection: '#c0c5ce',
  }
};

// All 12 keys for transposition
const KEYS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const KEY_SEMITONES = { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 };

// Tuning configurations
const tuningConfigs = {
  guitar: {
    6: {
      standard: { notes: ['E', 'B', 'G', 'D', 'A', 'E'], label: 'Standard' },
      drop: { notes: ['E', 'B', 'G', 'D', 'A', 'D'], label: 'Drop D' },
    },
    7: {
      standard: { notes: ['E', 'B', 'G', 'D', 'A', 'E', 'B'], label: 'Standard' },
      drop: { notes: ['E', 'B', 'G', 'D', 'A', 'E', 'A'], label: 'Drop A' },
    },
    8: {
      standard: { notes: ['E', 'B', 'G', 'D', 'A', 'E', 'B', 'F#'], label: 'Standard' },
      drop: { notes: ['E', 'B', 'G', 'D', 'A', 'E', 'B', 'E'], label: 'Drop E' },
    },
  },
  bass: {
    4: {
      standard: { notes: ['G', 'D', 'A', 'E'], label: 'Standard' },
      drop: { notes: ['G', 'D', 'A', 'D'], label: 'Drop D' },
    },
    5: {
      standard: { notes: ['G', 'D', 'A', 'E', 'B'], label: 'Standard' },
      drop: { notes: ['G', 'D', 'A', 'E', 'A'], label: 'Drop A' },
    },
    6: {
      standard: { notes: ['C', 'G', 'D', 'A', 'E', 'B'], label: 'Standard' },
      drop: { notes: ['C', 'G', 'D', 'A', 'E', 'A'], label: 'Drop A' },
    },
  },
};

// Transpose note by semitones
const transposeNote = (note, semitones) => {
  const baseNote = note.replace(/[0-9]/g, '');
  const currentIdx = KEYS.indexOf(baseNote.toUpperCase());
  if (currentIdx === -1) return note;
  const newIdx = (currentIdx + semitones + 12) % 12;
  return KEYS[newIdx];
};

// Get tuning notes transposed to key
const getTuningNotes = (instrument, stringCount, tuning, key) => {
  const baseTuning = tuningConfigs[instrument]?.[stringCount]?.[tuning]?.notes || [];
  const semitones = KEY_SEMITONES[key] - KEY_SEMITONES['E'];
  return baseTuning.map(note => transposeNote(note, semitones));
};

// Instrument configurations (for drums only now)
const instrumentConfigs = {
  guitar: {
    6: ['e', 'B', 'G', 'D', 'A', 'E'],
    7: ['e', 'B', 'G', 'D', 'A', 'E', 'B'],
    8: ['e', 'B', 'G', 'D', 'A', 'E', 'B', 'F#'],
  },
  bass: {
    4: ['G', 'D', 'A', 'E'],
    5: ['G', 'D', 'A', 'E', 'B'],
    6: ['C', 'G', 'D', 'A', 'E', 'B'],
  },
  drums: {
    lines: [
      { id: 'china', name: 'CH', fullName: 'China' },
      { id: 'crash', name: 'CC', fullName: 'Crash' },
      { id: 'ride', name: 'RD', fullName: 'Ride' },
      { id: 'hihatOpen', name: 'HO', fullName: 'Hi-Hat Open' },
      { id: 'hihatClosed', name: 'HC', fullName: 'Hi-Hat Closed' },
      { id: 'tomHigh', name: 'TH', fullName: 'Tom High' },
      { id: 'tomMid', name: 'TM', fullName: 'Tom Mid' },
      { id: 'tomLow', name: 'TL', fullName: 'Tom Low' },
      { id: 'snare', name: 'SN', fullName: 'Snare' },
      { id: 'kick', name: 'KK', fullName: 'Kick' },
    ]
  }
};

// Valid inputs for each instrument type
const validInputs = {
  guitar: ['0','1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','h','p','/','\\','b','x','m','~','-'],
  bass: ['0','1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','h','p','/','\\','b','x','m','~','-'],
  drums: ['x','o','X','O','-','f','g','d','b','r'],
};

// Technique labels
const techniques = {
  'h': 'hammer-on',
  'p': 'pull-off',
  '/': 'slide up',
  '\\': 'slide down',
  'b': 'bend',
  'x': 'dead note',
  'm': 'palm mute',
  '~': 'vibrato',
};

const DEFAULT_BPM = 120;

// Time signature presets
const TIME_SIGNATURES = [
  { label: '4/4', beats: 4, noteValue: 4 },
  { label: '3/4', beats: 3, noteValue: 4 },
  { label: '2/4', beats: 2, noteValue: 4 },
  { label: '5/4', beats: 5, noteValue: 4 },
  { label: '6/8', beats: 6, noteValue: 8 },
  { label: '7/8', beats: 7, noteValue: 8 },
  { label: '12/8', beats: 12, noteValue: 8 },
];

// Note resolution presets (cells per quarter note)
const NOTE_RESOLUTIONS = [
  { label: '1/32', perQuarter: 8 },
  { label: '1/16', perQuarter: 4 },
  { label: '1/8', perQuarter: 2 },
  { label: '1/4', perQuarter: 1 },
  { label: '1/2', perQuarter: 0.5 },
  { label: '1/32T', perQuarter: 12 },
  { label: '1/16T', perQuarter: 6 },
  { label: '1/8T', perQuarter: 3 },
  { label: '1/4T', perQuarter: 1.5 },
  { label: '1/2T', perQuarter: 0.75 },
];

// Calculate cells per measure based on time signature and resolution
const getCellsPerMeasure = (timeSig, resolution) => {
  const quartersPerMeasure = timeSig.noteValue === 4
    ? timeSig.beats
    : timeSig.beats / 2;
  return Math.round(quartersPerMeasure * resolution.perQuarter);
};

// Generate unique ID
const generateId = () => Math.random().toString(36).substr(2, 9);

// Initial riff creator
const createSection = (name = 'New Riff') => ({
  id: generateId(),
  name,
  measures: 1,
  repeat: 1,
});

// Initial measure data creator
const createEmptyMeasure = (instrument, stringCount, cellsPerMeasure = 16) => {
  if (instrument === 'drums') {
    const lines = instrumentConfigs.drums.lines.length;
    return Array(lines).fill(null).map(() => Array(cellsPerMeasure).fill('-'));
  }
  return Array(stringCount).fill(null).map(() => Array(cellsPerMeasure).fill('-'));
};

// Main App Component
function TabApp() {
  const [theme, setTheme] = useState('dark');
  const [activeInstrument, setActiveInstrument] = useState('guitar');
  const [stringCounts, setStringCounts] = useState({ guitar: 6, bass: 4 });
  const [tunings, setTunings] = useState({ guitar: 'standard', bass: 'standard' });
  const [projectKey, setProjectKey] = useState('E');
  const [projectName, setProjectName] = useState('Untitled Project');
  const [bpm, setBpm] = useState(DEFAULT_BPM);
  const [timeSignature, setTimeSignature] = useState(TIME_SIGNATURES[0]);
  const [noteResolution, setNoteResolution] = useState(NOTE_RESOLUTIONS[1]);
  const [sections, setSections] = useState([createSection('Intro')]);
  const [tabData, setTabData] = useState({});
  const [selectedCells, setSelectedCells] = useState([]);
  const [selectionStart, setSelectionStart] = useState(null);
  const [isSelecting, setIsSelecting] = useState(false);
  const [clipboard, setClipboard] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isMuted, setIsMuted] = useState(true);
  const [clickTrack, setClickTrack] = useState(false);
  const [playbackPosition, setPlaybackPosition] = useState(null);
  const [editingSection, setEditingSection] = useState(null);
  const [editingSectionName, setEditingSectionName] = useState('');
  const [focusMode, setFocusMode] = useState(false);
  const [showLegend, setShowLegend] = useState(false);
  const [mobileInputCell, setMobileInputCell] = useState(null);
  const [powerChordMode, setPowerChordMode] = useState(false);

  const mobileInputRef = useRef(null);
  const playbackRef = useRef(null);
  const audioContextRef = useRef(null);

  const colors = themes[theme];
  const cellsPerMeasure = getCellsPerMeasure(timeSignature, noteResolution);

  // Initialize tab data for a section/instrument combo if not exists
  const getTabData = useCallback((sectionId, instrument) => {
    const key = `${sectionId}-${instrument}`;
    if (!tabData[key]) {
      const section = sections.find(s => s.id === sectionId);
      if (!section) return [];
      const stringCount = instrument === 'drums' ? instrumentConfigs.drums.lines.length : stringCounts[instrument];
      const measures = Array(section.measures).fill(null).map(() => createEmptyMeasure(instrument, stringCount, cellsPerMeasure));
      return measures;
    }
    return tabData[key];
  }, [tabData, sections, stringCounts]);

  // Update tab data
  const updateTabData = useCallback((sectionId, instrument, newData) => {
    const key = `${sectionId}-${instrument}`;
    setTabData(prev => ({ ...prev, [key]: newData }));
  }, []);

  // Initialize data when sections change
  useEffect(() => {
    const newTabData = { ...tabData };
    sections.forEach(section => {
      ['guitar', 'bass', 'drums'].forEach(instrument => {
        const key = `${section.id}-${instrument}`;
        if (!newTabData[key]) {
          const stringCount = instrument === 'drums' ? instrumentConfigs.drums.lines.length : stringCounts[instrument];
          newTabData[key] = Array(section.measures).fill(null).map(() => createEmptyMeasure(instrument, stringCount, cellsPerMeasure));
        }
      });
    });
    setTabData(newTabData);
  }, [sections]);

  // Resize measures when time signature changes
  useEffect(() => {
    const newTabData = {};
    Object.entries(tabData).forEach(([key, measures]) => {
      newTabData[key] = measures.map(measure =>
        measure.map(string => {
          const currentLength = string.length;
          if (currentLength === cellsPerMeasure) return string;
          if (currentLength < cellsPerMeasure) {
            return [...string, ...Array(cellsPerMeasure - currentLength).fill('-')];
          } else {
            return string.slice(0, cellsPerMeasure);
          }
        })
      );
    });
    setTabData(newTabData);
  }, [cellsPerMeasure]);

  // Mobile input handler
  const handleMobileInput = (e) => {
    const value = e.target.value;
    if (mobileInputCell) {
      const { sectionId, measureIdx, stringIdx, cellIdx } = mobileInputCell;
      const data = getTabData(sectionId, activeInstrument);
      const currentValue = data[measureIdx]?.[stringIdx]?.[cellIdx] || '-';

      const newChar = value.length > currentValue.length || currentValue === '-'
        ? value.slice(-1)
        : value;

      if (newChar) {
        const validChars = validInputs[activeInstrument];
        if (validChars.includes(newChar) || (newChar >= '0' && newChar <= '9')) {
          if (data[measureIdx]) {
            const newData = data.map((measure, mIdx) =>
              measure.map((string, sIdx) =>
                string.map((cell, cIdx) => {
                  if (mIdx === measureIdx && sIdx === stringIdx && cIdx === cellIdx) {
                    return newChar;
                  }
                  return cell;
                })
              )
            );
            updateTabData(sectionId, activeInstrument, newData);
          }
        }
      }
    }
  };

  // Get current cell value for mobile input
  const getMobileInputValue = () => {
    if (!mobileInputCell) return '';
    const { sectionId, measureIdx, stringIdx, cellIdx } = mobileInputCell;
    const data = getTabData(sectionId, activeInstrument);
    const value = data[measureIdx]?.[stringIdx]?.[cellIdx];
    return value === '-' ? '' : value || '';
  };

  const openMobileKeyboard = (sectionId, measureIdx, stringIdx, cellIdx) => {
    const cellKey = `${sectionId}-${measureIdx}-${stringIdx}-${cellIdx}`;
    setSelectionStart({ sectionId, measureIdx, stringIdx, cellIdx });
    setSelectedCells([cellKey]);
    setMobileInputCell({ sectionId, measureIdx, stringIdx, cellIdx });
  };

  const closeMobileInput = () => {
    setMobileInputCell(null);
  };

  // Focus input when mobile input cell changes
  useEffect(() => {
    if (mobileInputCell && mobileInputRef.current) {
      mobileInputRef.current.focus();
    }
  }, [mobileInputCell]);

  // Cell click handler
  const handleCellClick = (sectionId, measureIdx, stringIdx, cellIdx, e) => {
    const cellKey = `${sectionId}-${measureIdx}-${stringIdx}-${cellIdx}`;

    if (e.shiftKey && selectionStart) {
      const cells = getCellsBetween(selectionStart, { sectionId, measureIdx, stringIdx, cellIdx });
      setSelectedCells(cells);
    } else {
      setSelectionStart({ sectionId, measureIdx, stringIdx, cellIdx });
      setSelectedCells([cellKey]);
    }
  };

  // Mouse down for drag selection
  const handleMouseDown = (sectionId, measureIdx, stringIdx, cellIdx, e) => {
    if (e.button !== 0) return;
    setIsSelecting(true);
    setSelectionStart({ sectionId, measureIdx, stringIdx, cellIdx });
    setSelectedCells([`${sectionId}-${measureIdx}-${stringIdx}-${cellIdx}`]);
  };

  // Mouse enter during selection
  const handleMouseEnter = (sectionId, measureIdx, stringIdx, cellIdx) => {
    if (!isSelecting || !selectionStart) return;
    const cells = getCellsBetween(selectionStart, { sectionId, measureIdx, stringIdx, cellIdx });
    setSelectedCells(cells);
  };

  // Mouse up
  const handleMouseUp = () => {
    setIsSelecting(false);
  };

  // Get cells between two points
  const getCellsBetween = (start, end) => {
    if (start.sectionId !== end.sectionId) {
      return [`${end.sectionId}-${end.measureIdx}-${end.stringIdx}-${end.cellIdx}`];
    }

    const cells = [];
    const minMeasure = Math.min(start.measureIdx, end.measureIdx);
    const maxMeasure = Math.max(start.measureIdx, end.measureIdx);
    const minString = Math.min(start.stringIdx, end.stringIdx);
    const maxString = Math.max(start.stringIdx, end.stringIdx);
    const minCell = Math.min(start.cellIdx, end.cellIdx);
    const maxCell = Math.max(start.cellIdx, end.cellIdx);

    for (let m = minMeasure; m <= maxMeasure; m++) {
      for (let s = minString; s <= maxString; s++) {
        const startCell = m === minMeasure ? minCell : 0;
        const endCell = m === maxMeasure ? maxCell : cellsPerMeasure - 1;
        for (let c = startCell; c <= endCell; c++) {
          cells.push(`${start.sectionId}-${m}-${s}-${c}`);
        }
      }
    }
    return cells;
  };

  // Keyboard input handler
  const handleKeyDown = useCallback((e) => {
    if (selectedCells.length === 0) return;
    if (editingSection) return;

    const key = e.key;

    if ((e.ctrlKey || e.metaKey) && key === 'c') {
      e.preventDefault();
      copySelection();
      return;
    }

    if ((e.ctrlKey || e.metaKey) && key === 'v') {
      e.preventDefault();
      pasteSelection();
      return;
    }

    if (key === 'Delete' || key === 'Backspace') {
      e.preventDefault();
      deleteSelection();
      return;
    }

    if (key === 'Escape') {
      closeMobileInput();
      return;
    }

    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
      e.preventDefault();
      navigateSelection(key);
      return;
    }

    const validChars = validInputs[activeInstrument];
    if (validChars.includes(key) || (key >= '0' && key <= '9')) {
      e.preventDefault();
      inputValue(key);
    }
  }, [selectedCells, activeInstrument, editingSection]);

  // Input value to selected cells
  const inputValue = (value) => {
    if (selectedCells.length === 0) return;

    const cellKey = selectedCells[0];
    const [sectionId, measureIdx, stringIdx, cellIdx] = cellKey.split('-');
    const data = getTabData(sectionId, activeInstrument);
    const mIdx = parseInt(measureIdx);
    const sIdx = parseInt(stringIdx);
    const cIdx = parseInt(cellIdx);

    if (!data[mIdx]) return;

    const fret = parseInt(value);
    const isPowerChord = powerChordMode && !isNaN(fret) && activeInstrument !== 'drums';
    const stringCount = stringCounts[activeInstrument];
    const isDropTuning = tunings[activeInstrument] === 'drop';

    const newData = data.map((measure, measureIndex) =>
      measure.map((string, stringIndex) =>
        string.map((cell, cellIndex) => {
          if (measureIndex !== mIdx || cellIndex !== cIdx) return cell;

          // Root note
          if (stringIndex === sIdx) {
            return value;
          }

          // Power chord: add 5th and octave (going UP toward higher strings)
          if (isPowerChord) {
            const isRootOnLowest = sIdx === stringCount - 1;
            // 5th: one string up (lower index)
            if (stringIndex === sIdx - 1 && sIdx - 1 >= 0) {
              const fifthFret = (isDropTuning && isRootOnLowest) ? fret : fret + 2;
              return fifthFret <= 24 ? String(fifthFret) : cell;
            }
            // Octave: two strings up
            if (stringIndex === sIdx - 2 && sIdx - 2 >= 0) {
              const octaveFret = (isDropTuning && isRootOnLowest) ? fret : fret + 2;
              return octaveFret <= 24 ? String(octaveFret) : cell;
            }
          }

          return cell;
        })
      )
    );

    updateTabData(sectionId, activeInstrument, newData);
  };

  // Navigate selection with arrow keys
  const navigateSelection = (direction) => {
    if (selectedCells.length === 0) return;

    const cellKey = selectedCells[0];
    const [sectionId, measureIdx, stringIdx, cellIdx] = cellKey.split('-').map((v, i) => i === 0 ? v : parseInt(v));
    const data = getTabData(sectionId, activeInstrument);

    let newMeasure = measureIdx;
    let newString = stringIdx;
    let newCell = cellIdx;

    const stringCount = activeInstrument === 'drums' ? instrumentConfigs.drums.lines.length : stringCounts[activeInstrument];

    switch (direction) {
      case 'ArrowUp':
        newString = Math.max(0, stringIdx - 1);
        break;
      case 'ArrowDown':
        newString = Math.min(stringCount - 1, stringIdx + 1);
        break;
      case 'ArrowLeft':
        if (cellIdx > 0) {
          newCell = cellIdx - 1;
        } else if (measureIdx > 0) {
          newMeasure = measureIdx - 1;
          newCell = cellsPerMeasure - 1;
        }
        break;
      case 'ArrowRight':
        if (cellIdx < cellsPerMeasure - 1) {
          newCell = cellIdx + 1;
        } else if (measureIdx < data.length - 1) {
          newMeasure = measureIdx + 1;
          newCell = 0;
        }
        break;
    }

    const newKey = `${sectionId}-${newMeasure}-${newString}-${newCell}`;
    setSelectedCells([newKey]);
    setSelectionStart({ sectionId, measureIdx: newMeasure, stringIdx: newString, cellIdx: newCell });
  };

  // Copy selection
  const copySelection = () => {
    if (selectedCells.length === 0) return;

    const cellData = selectedCells.map(cellKey => {
      const [sectionId, measureIdx, stringIdx, cellIdx] = cellKey.split('-');
      const data = getTabData(sectionId, activeInstrument);
      return {
        stringIdx: parseInt(stringIdx),
        cellIdx: parseInt(cellIdx),
        measureIdx: parseInt(measureIdx),
        value: data[parseInt(measureIdx)]?.[parseInt(stringIdx)]?.[parseInt(cellIdx)] || '-'
      };
    });

    setClipboard({ instrument: activeInstrument, cells: cellData });
  };

  // Paste selection
  const pasteSelection = () => {
    if (!clipboard || selectedCells.length === 0) return;
    if (clipboard.instrument !== activeInstrument) return;

    const targetKey = selectedCells[0];
    const [targetSectionId, targetMeasureIdx, targetStringIdx, targetCellIdx] = targetKey.split('-').map((v, i) => i === 0 ? v : parseInt(v));

    const data = getTabData(targetSectionId, activeInstrument);
    const newData = JSON.parse(JSON.stringify(data));

    const minString = Math.min(...clipboard.cells.map(c => c.stringIdx));
    const minCell = Math.min(...clipboard.cells.map(c => c.cellIdx));
    const minMeasure = Math.min(...clipboard.cells.map(c => c.measureIdx));

    clipboard.cells.forEach(cell => {
      const newStringIdx = targetStringIdx + (cell.stringIdx - minString);
      const newCellIdx = targetCellIdx + (cell.cellIdx - minCell);
      const newMeasureIdx = targetMeasureIdx + (cell.measureIdx - minMeasure);

      if (newData[newMeasureIdx]?.[newStringIdx]?.[newCellIdx] !== undefined) {
        newData[newMeasureIdx][newStringIdx][newCellIdx] = cell.value;
      }
    });

    updateTabData(targetSectionId, activeInstrument, newData);
  };

  // Delete selection
  const deleteSelection = () => {
    if (selectedCells.length === 0) return;

    const grouped = {};
    selectedCells.forEach(cellKey => {
      const [sectionId] = cellKey.split('-');
      if (!grouped[sectionId]) grouped[sectionId] = [];
      grouped[sectionId].push(cellKey);
    });

    Object.entries(grouped).forEach(([sectionId, cells]) => {
      const data = getTabData(sectionId, activeInstrument);
      const newData = JSON.parse(JSON.stringify(data));

      cells.forEach(cellKey => {
        const [, measureIdx, stringIdx, cellIdx] = cellKey.split('-').map((v, i) => i === 0 ? v : parseInt(v));
        if (newData[measureIdx]?.[stringIdx]?.[cellIdx] !== undefined) {
          newData[measureIdx][stringIdx][cellIdx] = '-';
        }
      });

      updateTabData(sectionId, activeInstrument, newData);
    });
  };

  // Add riff
  const addSection = () => {
    const newSection = createSection(`Riff ${sections.length + 1}`);
    setSections([...sections, newSection]);
  };

  // Delete section
  const deleteSection = (sectionId) => {
    if (sections.length <= 1) return;
    setSections(sections.filter(s => s.id !== sectionId));
    const newTabData = { ...tabData };
    ['guitar', 'bass', 'drums'].forEach(instrument => {
      delete newTabData[`${sectionId}-${instrument}`];
    });
    setTabData(newTabData);
  };

  // Duplicate section
  const duplicateSection = (sectionId) => {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    const newSection = { ...section, id: generateId(), name: `${section.name} (copy)` };
    const idx = sections.findIndex(s => s.id === sectionId);
    const newSections = [...sections];
    newSections.splice(idx + 1, 0, newSection);
    setSections(newSections);

    const newTabData = { ...tabData };
    ['guitar', 'bass', 'drums'].forEach(instrument => {
      const sourceKey = `${sectionId}-${instrument}`;
      const targetKey = `${newSection.id}-${instrument}`;
      if (tabData[sourceKey]) {
        newTabData[targetKey] = JSON.parse(JSON.stringify(tabData[sourceKey]));
      }
    });
    setTabData(newTabData);
  };

  // Update section properties
  const updateSection = (sectionId, updates) => {
    setSections(sections.map(s => s.id === sectionId ? { ...s, ...updates } : s));

    if (updates.measures !== undefined) {
      const section = sections.find(s => s.id === sectionId);
      ['guitar', 'bass', 'drums'].forEach(instrument => {
        const key = `${sectionId}-${instrument}`;
        const currentData = tabData[key] || [];
        const stringCount = instrument === 'drums' ? instrumentConfigs.drums.lines.length : stringCounts[instrument];

        if (updates.measures > currentData.length) {
          const newMeasures = Array(updates.measures - currentData.length).fill(null).map(() => createEmptyMeasure(instrument, stringCount, cellsPerMeasure));
          setTabData(prev => ({ ...prev, [key]: [...currentData, ...newMeasures] }));
        } else if (updates.measures < currentData.length) {
          setTabData(prev => ({ ...prev, [key]: currentData.slice(0, updates.measures) }));
        }
      });
    }
  };

  // Audio playback
  const initAudio = () => {
    if (!audioContextRef.current) {
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContextRef.current;
  };

  const playNote = (frequency, duration, type = 'sine') => {
    if (isMuted) return;
    const ctx = initAudio();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + duration);
  };

  const playClick = (isDownbeat = false) => {
    const ctx = initAudio();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(isDownbeat ? 1000 : 800, ctx.currentTime);

    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + 0.05);
  };

  const playDrumSound = (drumType) => {
    if (isMuted) return;
    const ctx = initAudio();

    const frequencies = {
      kick: 60,
      snare: 200,
      hihatClosed: 800,
      hihatOpen: 800,
      crash: 500,
      ride: 600,
      china: 450,
      tomHigh: 300,
      tomMid: 200,
      tomLow: 150,
    };

    const freq = frequencies[drumType] || 200;
    playNote(freq, drumType.includes('hihat') || drumType.includes('crash') || drumType.includes('china') || drumType.includes('ride') ? 0.1 : 0.2, drumType === 'kick' ? 'sine' : 'triangle');
  };

  const fretToFrequency = (stringIdx, fret, instrument) => {
    const baseFrequencies = {
      guitar: {
        6: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41],
        7: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41, 61.74],
        8: [329.63, 246.94, 196.00, 146.83, 110.00, 82.41, 61.74, 46.25],
      },
      bass: {
        4: [196.00, 146.83, 110.00, 82.41],
        5: [196.00, 146.83, 110.00, 82.41, 61.74],
        6: [261.63, 196.00, 146.83, 110.00, 82.41, 61.74],
      }
    };

    const stringCount = stringCounts[instrument];
    const baseFreq = baseFrequencies[instrument]?.[stringCount]?.[stringIdx] || 110;
    return baseFreq * Math.pow(2, fret / 12);
  };

  // Playback control
  const startPlayback = () => {
    if (isPlaying) {
      stopPlayback();
      return;
    }

    setIsPlaying(true);
    const msPerBeat = 60000 / bpm;
    const cellsPerBeat = noteResolution.perQuarter * (timeSignature.noteValue === 4 ? 1 : 0.5);
    const msPerCell = msPerBeat / cellsPerBeat;

    let currentSection = 0;
    let currentMeasure = 0;
    let currentCell = 0;
    let repeatCount = 0;

    const playStep = () => {
      if (currentSection >= sections.length) {
        stopPlayback();
        return;
      }

      const section = sections[currentSection];
      const data = getTabData(section.id, activeInstrument);

      setPlaybackPosition({ sectionId: section.id, measureIdx: currentMeasure, cellIdx: currentCell });

      // Play click track
      if (clickTrack) {
        const cellsPerBeat = Math.round(noteResolution.perQuarter * (timeSignature.noteValue === 4 ? 1 : 0.5));
        if (cellsPerBeat > 0 && currentCell % cellsPerBeat === 0) {
          const isDownbeat = currentCell === 0;
          playClick(isDownbeat);
        }
      }

      if (data[currentMeasure]) {
        data[currentMeasure].forEach((string, stringIdx) => {
          const value = string[currentCell];
          if (value && value !== '-') {
            if (activeInstrument === 'drums') {
              const drumLine = instrumentConfigs.drums.lines[stringIdx];
              if (value === 'x' || value === 'X' || value === 'o' || value === 'O') {
                playDrumSound(drumLine.id);
              }
            } else {
              const fret = parseInt(value);
              if (!isNaN(fret)) {
                const freq = fretToFrequency(stringIdx, fret, activeInstrument);
                playNote(freq, msPerCell / 1000 * 2, 'sawtooth');
              } else if (value === 'm') {
                const freq = fretToFrequency(stringIdx, 0, activeInstrument);
                playNote(freq, msPerCell / 1000, 'square');
              }
            }
          }
        });
      }

      currentCell++;
      if (currentCell >= cellsPerMeasure) {
        currentCell = 0;
        currentMeasure++;
        if (currentMeasure >= section.measures) {
          currentMeasure = 0;
          repeatCount++;
          if (repeatCount >= section.repeat) {
            repeatCount = 0;
            currentSection++;
          }
        }
      }

      playbackRef.current = setTimeout(playStep, msPerCell);
    };

    playStep();
  };

  const stopPlayback = () => {
    setIsPlaying(false);
    setPlaybackPosition(null);
    if (playbackRef.current) {
      clearTimeout(playbackRef.current);
    }
  };

  // Export functions
  const exportToJSON = () => {
    const data = {
      projectName,
      bpm,
      timeSignature,
      noteResolution,
      projectKey,
      tunings,
      stringCounts,
      sections,
      tabData,
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${projectName.replace(/\s+/g, '_')}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const exportToText = () => {
    let text = `${projectName}\nBPM: ${bpm}\nTime: ${timeSignature.label}\nGrid: ${noteResolution.label}\nKey: ${projectKey}\n\n`;

    ['guitar', 'bass', 'drums'].forEach(instrument => {
      const tuningLabel = instrument !== 'drums'
        ? ` (${tuningConfigs[instrument]?.[stringCounts[instrument]]?.[tunings[instrument]]?.label || 'Standard'} in ${projectKey})`
        : '';
      text += `=== ${instrument.toUpperCase()}${tuningLabel} ===\n\n`;

      sections.forEach(section => {
        text += `[${section.name}]${section.repeat > 1 ? ` x${section.repeat}` : ''}\n`;
        const data = getTabData(section.id, instrument);

        if (instrument === 'drums') {
          instrumentConfigs.drums.lines.forEach((line, idx) => {
            text += `${line.name}|`;
            data.forEach(measure => {
              text += measure[idx].join('') + '|';
            });
            text += '\n';
          });
        } else {
          const strings = getTuningNotes(instrument, stringCounts[instrument], tunings[instrument], projectKey);
          strings.forEach((string, idx) => {
            text += `${string}|`;
            data.forEach(measure => {
              text += measure[idx].map(c => c.padStart(2, '-')).join('') + '|';
            });
            text += '\n';
          });
        }
        text += '\n';
      });
      text += '\n';
    });

    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${projectName.replace(/\s+/g, '_')}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const importFromJSON = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target.result);
        setProjectName(data.projectName || 'Untitled Project');
        setBpm(data.bpm || DEFAULT_BPM);
        setTimeSignature(data.timeSignature || TIME_SIGNATURES[0]);
        setNoteResolution(data.noteResolution || NOTE_RESOLUTIONS[1]);
        setProjectKey(data.projectKey || 'E');
        setTunings(data.tunings || { guitar: 'standard', bass: 'standard' });
        setStringCounts(data.stringCounts || { guitar: 6, bass: 4 });
        setSections(data.sections || [createSection('Intro')]);
        setTabData(data.tabData || {});
      } catch (err) {
        alert('Failed to load file');
      }
    };
    reader.readAsText(file);
  };

  // Event listeners
  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('mouseup', handleMouseUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleKeyDown]);

  // Styles
  const styles = {
    container: {
      backgroundColor: colors.bg,
      color: colors.text,
      minHeight: '100vh',
      fontFamily: "'SF Mono', 'Fira Code', 'Consolas', monospace",
      fontSize: '12px',
    },
    header: {
      backgroundColor: colors.bgAlt,
      padding: '10px 20px',
      borderBottom: `1px solid ${colors.border}`,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      flexWrap: 'wrap',
      gap: '12px',
    },
    headerLeft: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
    },
    headerRight: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
    },
    projectName: {
      backgroundColor: 'transparent',
      border: `1px solid ${colors.border}`,
      borderRadius: '3px',
      color: colors.textBright,
      fontSize: '12px',
      fontWeight: 'bold',
      padding: '5px 10px',
      fontFamily: 'inherit',
    },
    button: {
      backgroundColor: colors.bgHighlight,
      border: `1px solid ${colors.border}`,
      borderRadius: '3px',
      color: colors.text,
      cursor: 'pointer',
      padding: '5px 10px',
      fontSize: '12px',
      fontFamily: 'inherit',
      transition: 'background-color 0.2s',
    },
    buttonPrimary: {
      backgroundColor: colors.accent,
      color: colors.bg,
      borderColor: colors.accent,
    },
    buttonDanger: {
      backgroundColor: colors.red,
      color: colors.textBright,
      borderColor: colors.red,
    },
    toolbar: {
      backgroundColor: colors.bgAlt,
      padding: '8px 20px',
      borderBottom: `1px solid ${colors.border}`,
      display: 'flex',
      alignItems: 'center',
      gap: '20px',
      flexWrap: 'wrap',
    },
    toolbarGroup: {
      display: 'flex',
      alignItems: 'center',
      gap: '6px',
    },
    label: {
      color: colors.textMuted,
      fontSize: '11px',
      textTransform: 'lowercase',
    },
    select: {
      backgroundColor: colors.bg,
      border: `1px solid ${colors.border}`,
      borderRadius: '3px',
      color: colors.text,
      padding: '4px 8px',
      fontSize: '12px',
      fontFamily: 'inherit',
      cursor: 'pointer',
    },
    toggleContainer: {
      display: 'flex',
      backgroundColor: colors.bg,
      borderRadius: '3px',
      border: `1px solid ${colors.border}`,
      overflow: 'hidden',
    },
    toggleButton: {
      backgroundColor: 'transparent',
      border: 'none',
      color: colors.textMuted,
      cursor: 'pointer',
      padding: '4px 10px',
      fontSize: '12px',
      fontFamily: 'inherit',
      transition: 'all 0.2s',
    },
    toggleButtonActive: {
      backgroundColor: colors.accent,
      color: colors.bg,
    },
    input: {
      backgroundColor: colors.bg,
      border: `1px solid ${colors.border}`,
      borderRadius: '3px',
      color: colors.text,
      padding: '4px 8px',
      fontSize: '12px',
      fontFamily: 'inherit',
      width: '50px',
    },
    tabs: {
      display: 'flex',
      gap: '2px',
    },
    tab: {
      backgroundColor: 'transparent',
      border: 'none',
      borderBottom: `2px solid transparent`,
      color: colors.textMuted,
      cursor: 'pointer',
      padding: '6px 12px',
      fontSize: '12px',
      fontFamily: 'inherit',
      transition: 'all 0.2s',
    },
    tabActive: {
      borderBottomColor: colors.accent,
      color: colors.textBright,
    },
    content: {
      padding: '16px',
      overflowX: 'auto',
    },
    section: {
      marginBottom: '20px',
      backgroundColor: colors.bgAlt,
      borderRadius: '3px',
      border: `1px solid ${colors.border}`,
      overflow: 'hidden',
    },
    sectionHeader: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: '8px 12px',
      backgroundColor: colors.bgHighlight,
      borderBottom: `1px solid ${colors.border}`,
    },
    sectionTitle: {
      display: 'flex',
      alignItems: 'center',
      gap: '10px',
    },
    sectionName: {
      backgroundColor: 'transparent',
      border: 'none',
      color: colors.textBright,
      fontSize: '12px',
      fontWeight: 'bold',
      padding: '3px 6px',
      fontFamily: 'inherit',
      borderRadius: '3px',
    },
    sectionNameEditing: {
      backgroundColor: colors.bg,
      border: `1px solid ${colors.accent}`,
    },
    sectionControls: {
      display: 'flex',
      alignItems: 'center',
      gap: '6px',
    },
    smallInput: {
      backgroundColor: colors.bg,
      border: `1px solid ${colors.border}`,
      borderRadius: '3px',
      color: colors.text,
      padding: '3px 6px',
      fontSize: '11px',
      fontFamily: 'inherit',
      width: '36px',
      textAlign: 'center',
    },
    smallButton: {
      backgroundColor: 'transparent',
      border: `1px solid ${colors.border}`,
      color: colors.textMuted,
      cursor: 'pointer',
      padding: '3px 8px',
      fontSize: '11px',
      borderRadius: '3px',
      transition: 'all 0.2s',
      fontFamily: 'inherit',
    },
    gridContainer: {
      padding: '12px',
      overflowX: 'auto',
    },
    measureContainer: {
      display: 'flex',
      gap: '4px',
    },
    stringLabels: {
      display: 'flex',
      flexDirection: 'column',
      marginRight: '6px',
    },
    stringLabel: {
      height: '20px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'flex-end',
      paddingRight: '6px',
      color: colors.textMuted,
      fontSize: '11px',
      fontWeight: 'normal',
    },
    measure: {
      display: 'flex',
      flexDirection: 'column',
      borderLeft: `2px solid ${colors.border}`,
      borderRight: `1px solid ${colors.border}`,
    },
    measureNumber: {
      textAlign: 'center',
      color: colors.textMuted,
      fontSize: '10px',
      marginBottom: '3px',
    },
    row: {
      display: 'flex',
      borderBottom: `1px solid ${colors.border}`,
    },
    cell: {
      width: '20px',
      height: '20px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontSize: '10px',
      cursor: 'pointer',
      borderRight: `1px solid ${colors.bg}`,
      transition: 'background-color 0.1s',
      userSelect: 'none',
    },
    cellBeat: {
      borderRightColor: colors.border,
    },
    cellSelected: {
      backgroundColor: colors.selection,
      outline: `1px solid ${colors.accent}`,
    },
    cellPlaying: {
      backgroundColor: colors.accent,
      color: colors.bg,
    },
    legend: {
      padding: '12px 20px',
      backgroundColor: colors.bgAlt,
      borderTop: `1px solid ${colors.border}`,
      display: 'flex',
      flexWrap: 'wrap',
      gap: '24px',
    },
    legendToggleBar: {
      padding: '8px 20px',
      backgroundColor: colors.bgAlt,
      borderTop: `1px solid ${colors.border}`,
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
    },
    legendSection: {
      minWidth: '180px',
    },
    legendSectionTitle: {
      color: colors.textBright,
      fontSize: '11px',
      fontWeight: 'bold',
      marginBottom: '8px',
      borderBottom: `1px solid ${colors.border}`,
      paddingBottom: '4px',
    },
    legendGrid: {
      display: 'flex',
      flexDirection: 'column',
      gap: '4px',
    },
    legendItem: {
      display: 'flex',
      alignItems: 'center',
      gap: '6px',
      fontSize: '11px',
      color: colors.textMuted,
    },
    legendKey: {
      backgroundColor: colors.bgHighlight,
      padding: '1px 5px',
      borderRadius: '2px',
      fontWeight: 'bold',
      color: colors.textBright,
      minWidth: '24px',
      textAlign: 'center',
    },
    mobileInputOverlay: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.1)',
      display: 'flex',
      alignItems: 'flex-end',
      justifyContent: 'center',
      zIndex: 1000,
      padding: '20px',
    },
    mobileInputBox: {
      backgroundColor: colors.bgAlt,
      border: `1px solid ${colors.border}`,
      borderRadius: '6px',
      padding: '16px',
      width: '100%',
      maxWidth: '320px',
      marginBottom: '20px',
    },
    mobileInputLabel: {
      color: colors.textMuted,
      fontSize: '11px',
      marginBottom: '8px',
    },
    mobileInputField: {
      width: '100%',
      backgroundColor: colors.bg,
      border: `1px solid ${colors.accent}`,
      borderRadius: '3px',
      color: colors.textBright,
      fontSize: '18px',
      padding: '12px',
      fontFamily: 'inherit',
      textAlign: 'center',
      boxSizing: 'border-box',
    },
    mobileInputHint: {
      color: colors.textMuted,
      fontSize: '10px',
      marginTop: '8px',
      textAlign: 'center',
    },
    mobileInputButtons: {
      display: 'flex',
      gap: '8px',
      marginTop: '12px',
    },
    mobileInputButton: {
      flex: 1,
      backgroundColor: colors.bgHighlight,
      border: `1px solid ${colors.border}`,
      borderRadius: '3px',
      color: colors.text,
      fontSize: '12px',
      padding: '10px',
      fontFamily: 'inherit',
      cursor: 'pointer',
    },
    mobileInputButtonPrimary: {
      backgroundColor: colors.accent,
      borderColor: colors.accent,
      color: colors.bg,
    },
  };

  const renderGrid = (section) => {
    const data = getTabData(section.id, activeInstrument);
    const stringCount = activeInstrument === 'drums' ? instrumentConfigs.drums.lines.length : stringCounts[activeInstrument];
    const labels = activeInstrument === 'drums'
      ? instrumentConfigs.drums.lines.map(l => l.name)
      : getTuningNotes(activeInstrument, stringCounts[activeInstrument], tunings[activeInstrument], projectKey);

    return (
      <div style={styles.gridContainer}>
        <div style={styles.measureContainer}>
          <div style={styles.stringLabels}>
            <div style={{ height: '18px' }}></div>
            {labels.map((label, idx) => (
              <div key={idx} style={styles.stringLabel}>{label}</div>
            ))}
          </div>

          {data.map((measure, measureIdx) => (
            <div key={measureIdx} style={styles.measure}>
              <div style={styles.measureNumber}>{measureIdx + 1}</div>
              {measure.map((string, stringIdx) => (
                <div key={stringIdx} style={styles.row}>
                  {string.map((cell, cellIdx) => {
                    const cellKey = `${section.id}-${measureIdx}-${stringIdx}-${cellIdx}`;
                    const isSelected = selectedCells.includes(cellKey);
                    const isPlaying = playbackPosition?.sectionId === section.id &&
                                     playbackPosition?.measureIdx === measureIdx &&
                                     playbackPosition?.cellIdx === cellIdx;
                    const cellsPerBeat = Math.round(noteResolution.perQuarter * (timeSignature.noteValue === 4 ? 1 : 0.5));
                    const isBeat = cellsPerBeat > 0 && (cellIdx + 1) % cellsPerBeat === 0;

                    return (
                      <div
                        key={cellIdx}
                        style={{
                          ...styles.cell,
                          ...(isBeat ? styles.cellBeat : {}),
                          ...(isSelected ? styles.cellSelected : {}),
                          ...(isPlaying ? styles.cellPlaying : {}),
                        }}
                        onMouseDown={(e) => handleMouseDown(section.id, measureIdx, stringIdx, cellIdx, e)}
                        onMouseEnter={() => handleMouseEnter(section.id, measureIdx, stringIdx, cellIdx)}
                        onClick={(e) => {
                          handleCellClick(section.id, measureIdx, stringIdx, cellIdx, e);
                          openMobileKeyboard(section.id, measureIdx, stringIdx, cellIdx);
                        }}
                        onTouchEnd={(e) => {
                          e.preventDefault();
                          openMobileKeyboard(section.id, measureIdx, stringIdx, cellIdx);
                        }}
                      >
                        {cell}
                      </div>
                    );
                  })}
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
    );
  };

  return (
    <div style={styles.container}>
      {/* Mobile input overlay */}
      {mobileInputCell && (
        <div style={styles.mobileInputOverlay} onClick={closeMobileInput}>
          <div style={styles.mobileInputBox} onClick={(e) => e.stopPropagation()}>
            <div style={styles.mobileInputLabel}>
              Enter value: 0-24 or h p / \ b x m ~
            </div>
            <input
              ref={mobileInputRef}
              type="tel"
              inputMode="numeric"
              style={styles.mobileInputField}
              value={getMobileInputValue()}
              onChange={handleMobileInput}
              autoComplete="off"
              autoCorrect="off"
              autoCapitalize="off"
              spellCheck="false"
            />
            <div style={styles.mobileInputButtons}>
              <button
                style={styles.mobileInputButton}
                onClick={closeMobileInput}
              >
                Close
              </button>
              <button
                style={{ ...styles.mobileInputButton, ...styles.mobileInputButtonPrimary }}
                onClick={() => {
                  const { sectionId, measureIdx, stringIdx, cellIdx } = mobileInputCell;
                  const nextCellIdx = cellIdx + 1;
                  if (nextCellIdx < cellsPerMeasure) {
                    setMobileInputCell({ sectionId, measureIdx, stringIdx, cellIdx: nextCellIdx });
                    setSelectedCells([`${sectionId}-${measureIdx}-${stringIdx}-${nextCellIdx}`]);
                  } else if (measureIdx + 1 < getTabData(sectionId, activeInstrument).length) {
                    setMobileInputCell({ sectionId, measureIdx: measureIdx + 1, stringIdx, cellIdx: 0 });
                    setSelectedCells([`${sectionId}-${measureIdx + 1}-${stringIdx}-0`]);
                  }
                  if (mobileInputRef.current) {
                    mobileInputRef.current.focus();
                  }
                }}
              >
                Next cell
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Header */}
      <div style={{...styles.header, ...(focusMode ? { padding: '8px 20px' } : {})}}>
        <div style={styles.headerLeft}>
          {focusMode ? (
            <span style={{ color: colors.textBright, fontSize: '12px', fontWeight: 'bold' }}>{projectName}</span>
          ) : (
            <input
              style={styles.projectName}
              value={projectName}
              onChange={(e) => setProjectName(e.target.value)}
              placeholder="Project name"
            />
          )}
        </div>
        <div style={styles.headerRight}>
          {!focusMode && (
            <>
              <input
                type="file"
                accept=".json"
                onChange={importFromJSON}
                style={{ display: 'none' }}
                id="import-file"
              />
              <label htmlFor="import-file" style={{ ...styles.button, cursor: 'pointer' }}>
                Open
              </label>
              <button style={styles.button} onClick={exportToJSON}>Save</button>
              <button style={styles.button} onClick={exportToText}>Export text</button>
            </>
          )}
          <button
            style={styles.button}
            onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
          >
            {theme === 'dark' ? 'Light' : 'Dark'}
          </button>
          <button
            style={{ ...styles.button, ...(focusMode ? styles.buttonPrimary : {}) }}
            onClick={() => setFocusMode(!focusMode)}
            title="Focus mode"
          >
            {focusMode ? 'Exit focus' : 'Focus'}
          </button>
        </div>
      </div>

      {/* Toolbar */}
      {!focusMode && (
        <div style={styles.toolbar}>
        <div style={styles.toolbarGroup}>
          <span style={styles.label}>Instrument</span>
          <div style={styles.tabs}>
            {['guitar', 'bass', 'drums'].map(inst => (
              <button
                key={inst}
                style={{
                  ...styles.tab,
                  ...(activeInstrument === inst ? styles.tabActive : {}),
                }}
                onClick={() => setActiveInstrument(inst)}
              >
                {inst.charAt(0).toUpperCase() + inst.slice(1)}
              </button>
            ))}
          </div>
        </div>

        {activeInstrument !== 'drums' && (
          <div style={styles.toolbarGroup}>
            <span style={styles.label}>Strings</span>
            <select
              style={styles.select}
              value={stringCounts[activeInstrument]}
              onChange={(e) => setStringCounts({ ...stringCounts, [activeInstrument]: parseInt(e.target.value) })}
            >
              {Object.keys(tuningConfigs[activeInstrument]).map(count => (
                <option key={count} value={count}>{count}-string</option>
              ))}
            </select>
          </div>
        )}

        {activeInstrument !== 'drums' && (
          <div style={styles.toolbarGroup}>
            <span style={styles.label}>Tuning</span>
            <div style={styles.toggleContainer}>
              <button
                style={{
                  ...styles.toggleButton,
                  ...(tunings[activeInstrument] === 'standard' ? styles.toggleButtonActive : {}),
                }}
                onClick={() => setTunings({ ...tunings, [activeInstrument]: 'standard' })}
              >
                Standard
              </button>
              <button
                style={{
                  ...styles.toggleButton,
                  ...(tunings[activeInstrument] === 'drop' ? styles.toggleButtonActive : {}),
                }}
                onClick={() => setTunings({ ...tunings, [activeInstrument]: 'drop' })}
              >
                Drop
              </button>
            </div>
          </div>
        )}

        {activeInstrument !== 'drums' && (
          <div style={styles.toolbarGroup}>
            <button
              style={{
                ...styles.button,
                ...(powerChordMode ? styles.buttonPrimary : {}),
              }}
              onClick={() => setPowerChordMode(!powerChordMode)}
              title="Auto-fill power chords (root + 5th + octave)"
            >
              Power chord
            </button>
          </div>
        )}

        <div style={styles.toolbarGroup}>
          <span style={styles.label}>Key</span>
          <select
            style={styles.select}
            value={projectKey}
            onChange={(e) => setProjectKey(e.target.value)}
          >
            {KEYS.map(key => (
              <option key={key} value={key}>{key}</option>
            ))}
          </select>
        </div>

        <div style={styles.toolbarGroup}>
          <span style={styles.label}>Time</span>
          <select
            style={styles.select}
            value={timeSignature.label}
            onChange={(e) => {
              const newTimeSig = TIME_SIGNATURES.find(t => t.label === e.target.value);
              if (newTimeSig) setTimeSignature(newTimeSig);
            }}
          >
            {TIME_SIGNATURES.map(ts => (
              <option key={ts.label} value={ts.label}>{ts.label}</option>
            ))}
          </select>
        </div>

        <div style={styles.toolbarGroup}>
          <span style={styles.label}>Grid</span>
          <select
            style={styles.select}
            value={noteResolution.label}
            onChange={(e) => {
              const newRes = NOTE_RESOLUTIONS.find(r => r.label === e.target.value);
              if (newRes) setNoteResolution(newRes);
            }}
          >
            {NOTE_RESOLUTIONS.map(res => (
              <option key={res.label} value={res.label}>{res.label}</option>
            ))}
          </select>
        </div>

        <div style={styles.toolbarGroup}>
          <span style={styles.label}>BPM</span>
          <input
            type="number"
            style={styles.input}
            value={bpm}
            onChange={(e) => setBpm(Math.max(40, Math.min(300, parseInt(e.target.value) || 120)))}
            min="40"
            max="300"
          />
        </div>

        <div style={styles.toolbarGroup}>
          <button
            style={{ ...styles.button, ...(isPlaying ? styles.buttonDanger : styles.buttonPrimary) }}
            onClick={startPlayback}
          >
            {isPlaying ? 'Stop' : 'Play'}
          </button>
          <button
            style={{ ...styles.button, opacity: isMuted ? 0.5 : 1 }}
            onClick={() => setIsMuted(!isMuted)}
          >
            {isMuted ? 'Unmute' : 'Mute'}
          </button>
          <button
            style={{
              ...styles.button,
              ...(clickTrack ? styles.buttonPrimary : {}),
            }}
            onClick={() => setClickTrack(!clickTrack)}
            title="Metronome click on each beat"
          >
            Click
          </button>
        </div>

        <div style={styles.toolbarGroup}>
          <button style={styles.button} onClick={addSection}>Add riff</button>
        </div>
      </div>
      )}

      {/* Content */}
      <div style={styles.content}>
        {sections.map((section, idx) => (
          <div key={section.id} style={styles.section}>
            <div style={styles.sectionHeader}>
              <div style={styles.sectionTitle}>
                {editingSection === section.id ? (
                  <input
                    style={{ ...styles.sectionName, ...styles.sectionNameEditing }}
                    value={editingSectionName}
                    onChange={(e) => setEditingSectionName(e.target.value)}
                    onBlur={() => {
                      updateSection(section.id, { name: editingSectionName });
                      setEditingSection(null);
                    }}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        updateSection(section.id, { name: editingSectionName });
                        setEditingSection(null);
                      }
                    }}
                    autoFocus
                  />
                ) : (
                  <span
                    style={styles.sectionName}
                    onDoubleClick={() => {
                      if (!focusMode) {
                        setEditingSection(section.id);
                        setEditingSectionName(section.name);
                      }
                    }}
                  >
                    {section.name}
                  </span>
                )}
                <span style={{ color: colors.textMuted, fontSize: '12px' }}>
                  {section.repeat > 1 && `${section.repeat}`}
                </span>
              </div>

              {!focusMode && (
              <div style={styles.sectionControls}>
                <span style={styles.label}>Measures</span>
                <input
                  type="number"
                  style={styles.smallInput}
                  value={section.measures}
                  onChange={(e) => updateSection(section.id, { measures: Math.max(1, parseInt(e.target.value) || 1) })}
                  min="1"
                />

                <span style={{ ...styles.label, marginLeft: '8px' }}>Repeat</span>
                <input
                  type="number"
                  style={styles.smallInput}
                  value={section.repeat}
                  onChange={(e) => updateSection(section.id, { repeat: Math.max(1, parseInt(e.target.value) || 1) })}
                  min="1"
                />

                <button
                  style={styles.smallButton}
                  onClick={() => duplicateSection(section.id)}
                  title="Duplicate section"
                >
                  Copy
                </button>

                {sections.length > 1 && (
                  <button
                    style={{ ...styles.smallButton, color: colors.red }}
                    onClick={() => deleteSection(section.id)}
                    title="Delete section"
                  >
                    Delete
                  </button>
                )}
              </div>
              )}
            </div>

            {renderGrid(section)}
          </div>
        ))}
      </div>

      {/* Legend Toggle & Panel */}
      <div style={styles.legendToggleBar}>
        <button
          style={{ ...styles.button, display: 'flex', alignItems: 'center', gap: '6px' }}
          onClick={() => setShowLegend(!showLegend)}
        >
          <span>{showLegend ? 'Hide legend' : 'Show legend'}</span>
        </button>
        {!showLegend && (
          <div style={{ marginLeft: 'auto', display: 'flex', gap: '16px', color: colors.textMuted, fontSize: '11px' }}>
            <span>Ctrl+C copy</span>
            <span>Ctrl+V paste</span>
            <span>Del clear</span>
            <span>Arrows navigate</span>
          </div>
        )}
      </div>
      {showLegend && (
      <div style={styles.legend}>
        <div style={styles.legendSection}>
          <div style={styles.legendSectionTitle}>Guitar and bass</div>
          <div style={styles.legendGrid}>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>0-24</span>
              <span>Fret number</span>
            </div>
            {Object.entries(techniques).map(([key, desc]) => (
              <div key={key} style={styles.legendItem}>
                <span style={styles.legendKey}>{key}</span>
                <span>{desc}</span>
              </div>
            ))}
          </div>
        </div>

        <div style={styles.legendSection}>
          <div style={styles.legendSectionTitle}>Drums</div>
          <div style={styles.legendGrid}>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>x / X</span>
              <span>Hit</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>o / O</span>
              <span>Accent hit</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>f</span>
              <span>Flam</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>g</span>
              <span>Ghost note</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>d</span>
              <span>Double stroke</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>b</span>
              <span>Buzz roll</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>r</span>
              <span>Rim shot</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>-</span>
              <span>Rest</span>
            </div>
          </div>
        </div>

        <div style={styles.legendSection}>
          <div style={styles.legendSectionTitle}>Drum kit lines</div>
          <div style={styles.legendGrid}>
            {instrumentConfigs.drums.lines.map(line => (
              <div key={line.id} style={styles.legendItem}>
                <span style={styles.legendKey}>{line.name}</span>
                <span>{line.fullName}</span>
              </div>
            ))}
          </div>
        </div>

        <div style={styles.legendSection}>
          <div style={styles.legendSectionTitle}>Keyboard shortcuts</div>
          <div style={styles.legendGrid}>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>Ctrl+C</span>
              <span>Copy selection</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>Ctrl+V</span>
              <span>Paste</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>Delete</span>
              <span>Clear selection</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>Arrows</span>
              <span>Navigate cells</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>Shift+click</span>
              <span>Extend selection</span>
            </div>
            <div style={styles.legendItem}>
              <span style={styles.legendKey}>Drag</span>
              <span>Select range</span>
            </div>
          </div>
        </div>
      </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<TabApp />);
  </script>
</body>
</html>